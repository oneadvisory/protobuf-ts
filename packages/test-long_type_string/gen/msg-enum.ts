// @generated by protobuf-ts 3.0.0 with parameter long_type_string
// @generated from protobuf file "msg-enum.proto" (package "spec", syntax proto3)
// tslint:disable
import { enumStringToNumber } from "@oneadvisory/protobuf-ts-runtime";
import type { BinaryWriteOptions } from "@oneadvisory/protobuf-ts-runtime";
import type { IBinaryWriter } from "@oneadvisory/protobuf-ts-runtime";
import { enumNumberToString } from "@oneadvisory/protobuf-ts-runtime";
import type { BinaryReadOptions } from "@oneadvisory/protobuf-ts-runtime";
import type { IBinaryReader } from "@oneadvisory/protobuf-ts-runtime";
import { UnknownFieldHandler } from "@oneadvisory/protobuf-ts-runtime";
import { WireType } from "@oneadvisory/protobuf-ts-runtime";
import type { PartialMessage } from "@oneadvisory/protobuf-ts-runtime";
import { reflectionMergePartial } from "@oneadvisory/protobuf-ts-runtime";
import { MessageType } from "@oneadvisory/protobuf-ts-runtime";
/**
 * @generated from protobuf message spec.EnumFieldMessage
 */
export interface EnumFieldMessage {
    /**
     * @generated from protobuf field: spec.SimpleEnum enum_field = 1;
     */
    enumField: SimpleEnum;
    /**
     * @generated from protobuf field: repeated spec.SimpleEnum repeated_enum_field = 2;
     */
    repeatedEnumField?: SimpleEnum[];
    /**
     * @generated from protobuf field: spec.AliasEnum alias_enum_field = 3;
     */
    aliasEnumField: AliasEnum;
    /**
     * @generated from protobuf field: spec.PrefixEnum prefix_enum_field = 4;
     */
    prefixEnumField: PrefixEnum;
}
/**
 * @generated from protobuf enum spec.EnumFieldMessage.TestEnum:
 *
 * enum TestEnum {
 *  ANY = 0;
 *  YES = 1;
 *  NO = 2;
 * }
 */
export type EnumFieldMessage_TestEnum = "ANY" | "YES" | "NO";
export const EnumFieldMessage_TestEnum = {
    /**
     * @generated from protobuf enum value: ANY = 0;
     */ ANY: "ANY",
    /**
     * @generated from protobuf enum value: YES = 1;
     */ YES: "YES",
    /**
     * @generated from protobuf enum value: NO = 2;
     */ NO: "NO"
} as const;
export const EnumFieldMessage_TestEnum$stringToNumber = {
    ANY: 0,
    YES: 1,
    NO: 2
} as const;
export const EnumFieldMessage_TestEnum$numberToString = {
    0: "ANY",
    1: "YES",
    2: "NO"
} as const;
/**
 * @generated from protobuf enum spec.SimpleEnum:
 *
 * enum SimpleEnum {
 *  ANY = 0;  // this is the default value
 *  YES = 1;  // value for positive outcome
 *  NO = 2;  // negative value
 * }
 */
export type SimpleEnum = "ANY" | "YES" | "NO";
export const SimpleEnum = {
    /** this is the default value
     * and this comment has more
     * than one line
     *
     * @generated from protobuf enum value: ANY = 0; */ ANY: "ANY",
    /** value for positive outcome
     *
     * @generated from protobuf enum value: YES = 1; */ YES: "YES",
    /** negative value
     *
     * @generated from protobuf enum value: NO = 2; */ NO: "NO"
} as const;
export const SimpleEnum$stringToNumber = {
    ANY: 0,
    YES: 1,
    NO: 2
} as const;
export const SimpleEnum$numberToString = {
    0: "ANY",
    1: "YES",
    2: "NO"
} as const;
/**
 * Both B and C have the same numerical value.
 *
 * @generated from protobuf enum spec.AliasEnum:
 *
 * enum AliasEnum {
 *  A = 0;
 *  B = 1;
 *  C = 1;
 * }
 */
export type AliasEnum = "A" | "B" | "C";
export const AliasEnum = {
    /**
     * @generated from protobuf enum value: A = 0;
     */ A: "A",
    /**
     * @generated from protobuf enum value: B = 1;
     */ B: "B",
    /**
     * @generated from protobuf enum value: C = 1;
     */ C: "C"
} as const;
export const AliasEnum$stringToNumber = {
    A: 0,
    B: 1,
    C: 1
} as const;
export const AliasEnum$numberToString = {
    0: "A",
    1: "B"
} as const;
/**
 * The generated enum values should drop the "PREFIX_"
 * part at the top if the target language allows
 * (basically every language except C++).
 *
 * @generated from protobuf enum spec.PrefixEnum:
 *
 * enum PrefixEnum {
 *  PREFIX_ENUM_ANY = 0;
 *  PREFIX_ENUM_YES = 1;
 *  PREFIX_ENUM_NO = 2;
 * }
 */
export type PrefixEnum = "ANY" | "YES" | "NO";
export const PrefixEnum = {
    /**
     * @generated from protobuf enum value: PREFIX_ENUM_ANY = 0;
     */ ANY: "ANY",
    /**
     * @generated from protobuf enum value: PREFIX_ENUM_YES = 1;
     */ YES: "YES",
    /**
     * @generated from protobuf enum value: PREFIX_ENUM_NO = 2;
     */ NO: "NO"
} as const;
export const PrefixEnum$stringToNumber = {
    ANY: 0,
    YES: 1,
    NO: 2
} as const;
export const PrefixEnum$numberToString = {
    0: "ANY",
    1: "YES",
    2: "NO"
} as const;
// @generated message type with reflection information, may provide speed optimized methods
class EnumFieldMessage$Type extends MessageType<EnumFieldMessage> {
    constructor() {
        super("spec.EnumFieldMessage", [
            { no: 1, name: "enum_field", kind: "enum", T: () => ["spec.SimpleEnum", SimpleEnum, undefined, SimpleEnum$stringToNumber] },
            { no: 2, name: "repeated_enum_field", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["spec.SimpleEnum", SimpleEnum, undefined, SimpleEnum$stringToNumber] },
            { no: 3, name: "alias_enum_field", kind: "enum", T: () => ["spec.AliasEnum", AliasEnum, undefined, AliasEnum$stringToNumber] },
            { no: 4, name: "prefix_enum_field", kind: "enum", T: () => ["spec.PrefixEnum", PrefixEnum, "PREFIX_ENUM_", PrefixEnum$stringToNumber] }
        ]);
    }
    create(value?: PartialMessage<EnumFieldMessage>): EnumFieldMessage {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.enumField = "ANY";
        message.repeatedEnumField = [];
        message.aliasEnumField = "A";
        message.prefixEnumField = "ANY";
        if (value !== undefined)
            reflectionMergePartial<EnumFieldMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EnumFieldMessage): EnumFieldMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* spec.SimpleEnum enum_field */ 1:
                    message.enumField = enumNumberToString(SimpleEnum$numberToString, reader.int32()) as any;
                    break;
                case /* repeated spec.SimpleEnum repeated_enum_field */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.repeatedEnumField?.push?.(enumNumberToString(SimpleEnum$numberToString, reader.int32()) as any);
                    else
                        message.repeatedEnumField?.push?.(enumNumberToString(SimpleEnum$numberToString, reader.int32()) as any);
                    break;
                case /* spec.AliasEnum alias_enum_field */ 3:
                    message.aliasEnumField = enumNumberToString(AliasEnum$numberToString, reader.int32()) as any;
                    break;
                case /* spec.PrefixEnum prefix_enum_field */ 4:
                    message.prefixEnumField = enumNumberToString(PrefixEnum$numberToString, reader.int32()) as any;
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EnumFieldMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* spec.SimpleEnum enum_field = 1; */
        if (message.enumField !== "ANY")
            writer.tag(1, WireType.Varint).int32(enumStringToNumber(SimpleEnum$stringToNumber, message.enumField));
        /* repeated spec.SimpleEnum repeated_enum_field = 2; */
        if (message.repeatedEnumField?.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.repeatedEnumField.length; i++)
                writer.int32(enumStringToNumber(SimpleEnum$stringToNumber, message.repeatedEnumField[i]));
            writer.join();
        }
        /* spec.AliasEnum alias_enum_field = 3; */
        if (message.aliasEnumField !== "A")
            writer.tag(3, WireType.Varint).int32(enumStringToNumber(AliasEnum$stringToNumber, message.aliasEnumField));
        /* spec.PrefixEnum prefix_enum_field = 4; */
        if (message.prefixEnumField !== "ANY")
            writer.tag(4, WireType.Varint).int32(enumStringToNumber(PrefixEnum$stringToNumber, message.prefixEnumField));
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spec.EnumFieldMessage
 */
export const EnumFieldMessage = new EnumFieldMessage$Type();
